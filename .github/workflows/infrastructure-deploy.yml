name: CostFX Infrastructure Deploy (Manual)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-west-2
  ECR_REPOSITORY_BACKEND: costfx-backend
  ECR_REPOSITORY_FRONTEND: costfx-frontend

jobs:
  # Determine environment and configuration
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      deploy: ${{ steps.env.outputs.deploy }}
    steps:
      - name: Determine environment
        id: env
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment || 'dev' }}"
          FORCE_DEPLOY="${{ github.event.inputs.force_deploy || 'false' }}"
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "deploy=true" >> $GITHUB_OUTPUT
          
          echo "ðŸ—ï¸ Infrastructure deployment requested"
          echo "Environment: $ENVIRONMENT"
          echo "Force deploy: $FORCE_DEPLOY"

  # Run application tests (MUST PASS for deployment)
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm ci

      - name: Run backend tests
        env:
          NODE_ENV: test
        run: |
          echo "ðŸ§ª Running backend unit tests (mocked)..."
          cd backend
          npm test
          echo "âœ… Backend tests passed!"

      - name: Run frontend tests
        run: |
          echo "ðŸ§ª Running frontend tests..."
          cd frontend
          npm test
          echo "âœ… Frontend tests passed!"

      - name: Run linting (warnings allowed)
        continue-on-error: true
        run: |
          echo "ðŸ” Running linting checks..."
          echo "Linting backend..."
          cd backend && npm run lint || echo "âš ï¸ Backend linting issues detected (proceeding anyway)"
          cd ..
          echo "Linting frontend..."
          cd frontend && npm run lint || echo "âš ï¸ Frontend linting issues detected (proceeding anyway)"
          echo "ðŸ“‹ Linting check completed"

  # Test Docker builds (after application tests pass)
  docker-test:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Test backend Docker build
        run: |
          echo "ðŸ³ Testing backend Docker build..."
          docker build -f deploy/docker/Dockerfile.backend --target test .

      - name: Test frontend Docker build
        run: |
          echo "ðŸ³ Testing frontend Docker build..."
          docker build -f deploy/docker/Dockerfile.frontend --target test .

  # Build and push Docker images
  build:
    needs: [setup, test, docker-test]
    runs-on: ubuntu-latest
    if: needs.setup.outputs.deploy == 'true'
    outputs:
      backend-image: ${{ steps.backend-image.outputs.image }}
      frontend-image: ${{ steps.frontend-image.outputs.image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend image
        id: backend-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG \
            -f deploy/docker/Dockerfile.backend \
            --target production .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push frontend image
        id: frontend-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        run: |
          # Set API URL based on environment
          if [[ $ENVIRONMENT == 'prod' ]]; then
            API_URL="https://cost-fx.com/api/v1"
          else
            API_URL="https://cost-fx.com/api/v1"
          fi
          
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG \
            -f deploy/docker/Dockerfile.frontend \
            --target production \
            --build-arg VITE_API_URL=$API_URL .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG" >> $GITHUB_OUTPUT

  # Deploy infrastructure with Terraform
  deploy:
    needs: [setup, build]
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Use the professional Terraform GitHub Actions
      - name: Terraform Plan
        uses: dflook/terraform-plan@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          path: deploy/terraform
          workspace: ${{ needs.setup.outputs.environment }}
          variables: |
            environment = "${{ needs.setup.outputs.environment }}"
            backend_image = "${{ needs.build.outputs.backend-image }}"
            frontend_image = "${{ needs.build.outputs.frontend-image }}"
          backend_config: |
            bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}
            key=env/${{ needs.setup.outputs.environment }}/infra.tfstate
            region=${{ env.AWS_REGION }}

      - name: Terraform Apply
        uses: dflook/terraform-apply@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          path: deploy/terraform
          workspace: ${{ needs.setup.outputs.environment }}
          variables: |
            environment = "${{ needs.setup.outputs.environment }}"
            backend_image = "${{ needs.build.outputs.backend-image }}"
            frontend_image = "${{ needs.build.outputs.frontend-image }}"
          backend_config: |
            bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}
            key=env/${{ needs.setup.outputs.environment }}/infra.tfstate
            region=${{ env.AWS_REGION }}
          auto_approve: true

      - name: Get deployment outputs
        uses: dflook/terraform-output@v1
        id: tf-outputs
        with:
          path: deploy/terraform
          workspace: ${{ needs.setup.outputs.environment }}
          backend_config: |
            bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}
            key=env/${{ needs.setup.outputs.environment }}/infra.tfstate
            region=${{ env.AWS_REGION }}

      - name: Set output variables
        run: |
          echo "LOAD_BALANCER_URL=${{ steps.tf-outputs.outputs.load_balancer_url }}" >> $GITHUB_ENV
          echo "BACKEND_URL=${{ steps.tf-outputs.outputs.backend_url }}" >> $GITHUB_ENV

  # Update SSM parameters with secrets
  update-secrets:
    needs: [setup, deploy]
    runs-on: ubuntu-latest
    if: needs.setup.outputs.deploy == 'true'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update application secrets
        run: |
          # Update JWT secret
          aws ssm put-parameter \
            --name '/costfx/${{ needs.setup.outputs.environment }}/jwt_secret' \
            --value '${{ secrets.JWT_SECRET }}' \
            --type SecureString \
            --overwrite \
            --region ${{ env.AWS_REGION }}

          # Update OpenAI API key
          aws ssm put-parameter \
            --name '/costfx/${{ needs.setup.outputs.environment }}/openai_api_key' \
            --value '${{ secrets.OPENAI_API_KEY }}' \
            --type SecureString \
            --overwrite \
            --region ${{ env.AWS_REGION }}

          # Update database password
          aws ssm put-parameter \
            --name '/costfx/${{ needs.setup.outputs.environment }}/db_password' \
            --value '${{ secrets.DB_PASSWORD }}' \
            --type SecureString \
            --overwrite \
            --region ${{ env.AWS_REGION }}

  # Health check deployment with retry logic
  health-check:
    needs: [setup, deploy, update-secrets]
    runs-on: ubuntu-latest
    if: needs.setup.outputs.deploy == 'true'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get deployment URLs
        uses: dflook/terraform-output@v1
        id: tf-outputs
        with:
          path: deploy/terraform
          workspace: ${{ needs.setup.outputs.environment }}
          backend_config: |
            bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}
            key=env/${{ needs.setup.outputs.environment }}/infra.tfstate
            region=${{ env.AWS_REGION }}

      - name: Wait for ECS service stability
        run: |
          echo "Waiting for ECS services to become stable..."
          aws ecs wait services-stable \
            --cluster costfx-${{ needs.setup.outputs.environment }}-cluster \
            --services costfx-${{ needs.setup.outputs.environment }}-backend costfx-${{ needs.setup.outputs.environment }}-frontend \
            --region ${{ env.AWS_REGION }}

      - name: Health check backend
        run: |
          BACKEND_URL="${{ steps.tf-outputs.outputs.backend_url }}"
          echo "Testing backend health at: $BACKEND_URL/api/v1/"
          
          for i in {1..30}; do
            if curl -f -s --connect-timeout 10 --max-time 30 "$BACKEND_URL/api/v1/" > /dev/null; then
              echo "âœ… Backend is healthy!"
              break
            fi
            echo "Attempt $i/30: Backend not ready, waiting 30s..."
            if [ $i -eq 30 ]; then
              echo "âŒ Backend health check failed after 15 minutes"
              exit 1
            fi
            sleep 30
          done

      - name: Health check frontend
        run: |
          FRONTEND_URL="${{ steps.tf-outputs.outputs.load_balancer_url }}"
          echo "Testing frontend health at: $FRONTEND_URL"
          
          for i in {1..20}; do
            if curl -f -s --connect-timeout 10 --max-time 30 "$FRONTEND_URL" > /dev/null; then
              echo "âœ… Frontend is healthy!"
              break
            fi
            echo "Attempt $i/20: Frontend not ready, waiting 30s..."
            if [ $i -eq 20 ]; then
              echo "âŒ Frontend health check failed after 10 minutes"
              exit 1
            fi
            sleep 30
          done

      - name: Test core API endpoints
        run: |
          BACKEND_URL="${{ steps.tf-outputs.outputs.backend_url }}"
          echo "Testing core API endpoints..."
          
          # Test restaurant endpoints
          curl -f -s --connect-timeout 10 --max-time 30 "$BACKEND_URL/api/v1/restaurants" || echo "âš ï¸ Restaurants endpoint not ready"
          
          # Test agent endpoints  
          curl -f -s --connect-timeout 10 --max-time 30 "$BACKEND_URL/api/v1/agents/health" || echo "âš ï¸ Agents health endpoint not ready"
          
          echo "ðŸŽ‰ Deployment health check completed!"

      - name: Deployment summary
        run: |
          echo "## ðŸ—ï¸ Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Tests Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Tests**: All tests passed âœ…" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Tests**: All tests passed âœ…" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Builds**: All containers built successfully âœ…" >> $GITHUB_STEP_SUMMARY
          echo "- **Linting**: Completed (warnings allowed) âš ï¸" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend URL**: ${{ steps.tf-outputs.outputs.load_balancer_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend URL**: ${{ steps.tf-outputs.outputs.backend_url }}/api/v1" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Image**: ${{ needs.build.outputs.backend-image }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Image**: ${{ needs.build.outputs.frontend-image }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Infrastructure deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "_This was a complete infrastructure deployment including Terraform changes._" >> $GITHUB_STEP_SUMMARY
