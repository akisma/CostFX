name: CostFX App Deployment

on:
  push:
    branches:
      - main
      - develop
      - feature/**
    paths:
      - 'frontend/**'
      - 'backend/**'
      - 'shared/**'
      - '.env*'
      - 'package.json'
      - 'deploy/docker/**'
  pull_request:
    branches:
      - main
    paths:
      - 'frontend/**'
      - 'backend/**'
      - 'shared/**'
      - '.env*'
      - 'package.json'
      - 'deploy/docker/**'

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-west-2
  ECR_REPOSITORY_BACKEND: costfx-dev-backend
  ECR_REPOSITORY_FRONTEND: costfx-dev-frontend
  ECS_CLUSTER: costfx-dev
  ECS_SERVICE_BACKEND: costfx-dev-backend
  ECS_SERVICE_FRONTEND: costfx-dev-frontend

jobs:
  # Determine if deployment should proceed
  setup:
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      backend_changed: ${{ steps.changes.outputs.backend }}
      frontend_changed: ${{ steps.changes.outputs.frontend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check for app changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'shared/**'
              - 'deploy/docker/Dockerfile.backend'
            frontend:
              - 'frontend/**'
              - 'shared/**'
              - 'deploy/docker/Dockerfile.frontend'
            env:
              - '.env*'
              - 'package.json'
            workflow:
              - '.github/workflows/**'

      - name: Determine deployment
        id: check
        run: |
          if [[ "${{ steps.changes.outputs.backend }}" == "true" || "${{ steps.changes.outputs.frontend }}" == "true" || "${{ steps.changes.outputs.env }}" == "true" || "${{ steps.changes.outputs.workflow }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "ðŸš€ App changes detected, will deploy"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No app changes detected, skipping deployment"
          fi

  # Run application tests (MUST PASS for deployment)
  test:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_deploy == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm ci

      - name: Run backend tests
        if: needs.setup.outputs.backend_changed == 'true'
        env:
          NODE_ENV: test
        run: |
          echo "ðŸ§ª Running backend unit tests (mocked)..."
          cd backend
          npm test
          echo "âœ… Backend tests passed!"

      - name: Run frontend tests
        if: needs.setup.outputs.frontend_changed == 'true'
        run: |
          echo "ðŸ§ª Running frontend tests..."
          cd frontend
          npm test
          echo "âœ… Frontend tests passed!"

      - name: Run linting (warnings allowed)
        continue-on-error: true
        run: |
          echo "ðŸ” Running linting checks..."
          if [[ "${{ needs.setup.outputs.backend_changed }}" == "true" ]]; then
            echo "Linting backend..."
            cd backend && npm run lint || echo "âš ï¸ Backend linting issues detected (proceeding anyway)"
            cd ..
          fi
          if [[ "${{ needs.setup.outputs.frontend_changed }}" == "true" ]]; then
            echo "Linting frontend..."
            cd frontend && npm run lint || echo "âš ï¸ Frontend linting issues detected (proceeding anyway)"
            cd ..
          fi
          echo "ðŸ“‹ Linting check completed"

  # Test Docker builds (after application tests pass)
  docker-test:
    runs-on: ubuntu-latest
    needs: [setup, test]
    if: needs.setup.outputs.should_deploy == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Test backend Docker build
        if: needs.setup.outputs.backend_changed == 'true'
        run: |
          echo "ðŸ³ Testing backend Docker build..."
          docker build -f deploy/docker/Dockerfile.backend --target test .

      - name: Test frontend Docker build
        if: needs.setup.outputs.frontend_changed == 'true'
        run: |
          echo "ðŸ³ Testing frontend Docker build..."
          docker build -f deploy/docker/Dockerfile.frontend --target test .

  # Build and push Docker images
  build:
    needs: [setup, test, docker-test]
    runs-on: ubuntu-latest
    if: needs.setup.outputs.should_deploy == 'true'
    outputs:
      backend_image: ${{ steps.backend.outputs.image }}
      frontend_image: ${{ steps.frontend.outputs.image }}
      backend_built: ${{ steps.backend.outputs.built }}
      frontend_built: ${{ steps.frontend.outputs.built }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend image
        id: backend
        if: needs.setup.outputs.backend_changed == 'true'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ðŸ—ï¸ Building backend image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG \
            -f deploy/docker/Dockerfile.backend \
            --target production .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "built=true" >> $GITHUB_OUTPUT
          echo "âœ… Backend image pushed: $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG"

      - name: Build and push frontend image
        id: frontend
        if: needs.setup.outputs.frontend_changed == 'true'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ðŸ—ï¸ Building frontend image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG \
            -f deploy/docker/Dockerfile.frontend \
            --target production \
            --build-arg VITE_API_URL="https://www.cost-fx.com/api/v1" .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "built=true" >> $GITHUB_OUTPUT
          echo "âœ… Frontend image pushed: $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG"

  # Deploy to ECS (only if push to main/develop)
  deploy:
    needs: [setup, build]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && needs.setup.outputs.should_deploy == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Download current backend task definition
        if: needs.build.outputs.backend_built == 'true'
        run: |
          echo "ðŸ“¥ Downloading current backend task definition..."
          aws ecs describe-task-definition \
            --task-definition costfx-dev-backend \
            --query taskDefinition > backend-task-definition.json

      - name: Update backend task definition
        if: needs.build.outputs.backend_built == 'true'
        id: backend-task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: backend-task-definition.json
          container-name: backend
          image: ${{ needs.build.outputs.backend_image }}

      - name: Deploy backend to ECS
        if: needs.build.outputs.backend_built == 'true'
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.backend-task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE_BACKEND }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Run database migrations
        if: needs.build.outputs.backend_built == 'true'
        run: |
          echo "ï¿½ Running database migrations via ECS RunTask..."
          
          # Get subnet and security group IDs for the migration task
          echo "ðŸ“‹ Getting network configuration..."
          PRIVATE_SUBNETS=$(aws ec2 describe-subnets --filters Name=tag:Name,Values=costfx-dev-private --query "Subnets[*].SubnetId" --output text)
          BACKEND_SG=$(aws ec2 describe-security-groups --filters Name=tag:Name,Values=costfx-dev-ecs-backend-sg --query "SecurityGroups[0].GroupId" --output text)
          
          echo "Private Subnets: $PRIVATE_SUBNETS"
          echo "Security Group: $BACKEND_SG"
          
          # Update migration task definition with the new backend image
          echo "ðŸ“ Updating migration task definition with new image..."
          aws ecs describe-task-definition --task-definition costfx-dev-migration --query 'taskDefinition' > migration-task-def.json
          
          # Update the image in the task definition
          NEW_IMAGE="${{ needs.build.outputs.backend_image }}"
          jq --arg image "$NEW_IMAGE" '.containerDefinitions[0].image = $image' migration-task-def.json > updated-migration-task-def.json
          
          # Remove unnecessary fields and register updated task definition
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' updated-migration-task-def.json > final-migration-task-def.json
          
          UPDATED_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://final-migration-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "Updated task definition: $UPDATED_TASK_DEF_ARN"
          
          # Run the migration task using the updated task definition
          echo "ðŸš€ Starting migration task..."
          TASK_ARN=$(aws ecs run-task \
            --cluster costfx-dev \
            --task-definition "$UPDATED_TASK_DEF_ARN" \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$(echo $PRIVATE_SUBNETS | tr ' ' ',')],securityGroups=[$BACKEND_SG],assignPublicIp=DISABLED}" \
            --query 'tasks[0].taskArn' --output text)
          
          echo "Migration task started: $TASK_ARN"
          
          # Wait for the task to complete
          echo "â³ Waiting for migration task to complete..."
          aws ecs wait tasks-stopped --cluster costfx-dev --tasks $TASK_ARN
          
          # Extract task ID from ARN for log stream name
          TASK_ID=$(echo $TASK_ARN | rev | cut -d'/' -f1 | rev)
          echo "ðŸ“‹ Task ID: $TASK_ID"
          
          # Check the exit code
          EXIT_CODE=$(aws ecs describe-tasks --cluster costfx-dev --tasks $TASK_ARN --query 'tasks[0].containers[0].exitCode' --output text)
          
          if [ "$EXIT_CODE" = "0" ]; then
            echo "âœ… Database migrations completed successfully!"
          else
            echo "âŒ Database migrations failed with exit code: $EXIT_CODE"
            
            # Wait a bit for CloudWatch logs to be available
            echo "â³ Waiting for logs to be available..."
            sleep 10
            
            # Get the logs for debugging with retry logic
            echo "ðŸ“‹ Migration logs:"
            for i in {1..5}; do
              echo "Attempt $i: Checking log stream ecs/migration/$TASK_ID"
              LOG_OUTPUT=$(aws logs get-log-events \
                --log-group-name "/ecs/costfx-dev-migration" \
                --log-stream-name "ecs/migration/$TASK_ID" \
                --query 'events[*].message' --output text 2>/dev/null)
              
              if [ $? -eq 0 ] && [ -n "$LOG_OUTPUT" ]; then
                # Output logs in chunks to avoid truncation
                echo "$LOG_OUTPUT" | tail -50
                echo "ðŸ“‹ Full log summary - last 50 lines shown above"
                
                # Also check for specific error patterns
                if echo "$LOG_OUTPUT" | grep -i "error\|failed\|exception" > /dev/null; then
                  echo "ðŸ” Error patterns found in logs:"
                  echo "$LOG_OUTPUT" | grep -i "error\|failed\|exception" | tail -10
                fi
                break
              else
                echo "Log stream not ready, waiting 5 seconds..."
                sleep 5
              fi
            done || echo "Could not retrieve logs after 5 attempts"
            
            # Also show task details for debugging
            echo "ðŸ“‹ Task details:"
            aws ecs describe-tasks --cluster costfx-dev --tasks $TASK_ARN --query 'tasks[0].containers[0]' || echo "Could not get task details"
            
            exit 1
          fi

      - name: Download current frontend task definition
        if: needs.build.outputs.frontend_built == 'true'
        run: |
          echo "ðŸ“¥ Downloading current frontend task definition..."
          aws ecs describe-task-definition \
            --task-definition costfx-dev-frontend \
            --query taskDefinition > frontend-task-definition.json

      - name: Update frontend task definition
        if: needs.build.outputs.frontend_built == 'true'
        id: frontend-task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: frontend-task-definition.json
          container-name: frontend
          image: ${{ needs.build.outputs.frontend_image }}

      - name: Deploy frontend to ECS
        if: needs.build.outputs.frontend_built == 'true'
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.frontend-task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE_FRONTEND }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

  # Health check deployment
  health-check:
    needs: [setup, build, deploy]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && needs.setup.outputs.should_deploy == 'true'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Health check backend
        if: needs.build.outputs.backend_built == 'true'
        run: |
          echo "ðŸ¥ Testing backend health..."
          BACKEND_URL="https://cost-fx.com/api/v1"
          
          for i in {1..20}; do
            if curl -f -s --connect-timeout 10 --max-time 30 "$BACKEND_URL/" > /dev/null; then
              echo "âœ… Backend is healthy!"
              break
            fi
            echo "Attempt $i/20: Backend not ready, waiting 30s..."
            if [ $i -eq 20 ]; then
              echo "âŒ Backend health check failed after 10 minutes"
              exit 1
            fi
            sleep 30
          done

      - name: Health check frontend
        if: needs.build.outputs.frontend_built == 'true'
        run: |
          echo "ðŸ¥ Testing frontend health..."
          FRONTEND_URL="https://cost-fx.com"
          
          for i in {1..20}; do
            if curl -f -s --connect-timeout 10 --max-time 30 "$FRONTEND_URL" > /dev/null; then
              echo "âœ… Frontend is healthy!"
              break
            fi
            echo "Attempt $i/20: Frontend not ready, waiting 30s..."
            if [ $i -eq 20 ]; then
              echo "âŒ Frontend health check failed after 10 minutes"
              exit 1
            fi
            sleep 30
          done

      - name: Test core API endpoints
        if: needs.build.outputs.backend_built == 'true'
        run: |
          echo "ðŸ§ª Testing core API endpoints..."
          BACKEND_URL="https://cost-fx.com/api/v1"
          
          # Test restaurant endpoints
          curl -f -s --connect-timeout 10 --max-time 30 "$BACKEND_URL/restaurants" || echo "âš ï¸ Restaurants endpoint not ready"
          
          # Test agent endpoints  
          curl -f -s --connect-timeout 10 --max-time 30 "$BACKEND_URL/agents/health" || echo "âš ï¸ Agents health endpoint not ready"

      - name: Deployment summary
        run: |
          echo "## ðŸš€ App Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Tests Passed" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.setup.outputs.backend_changed }}" == "true" ]]; then
            echo "- **Backend Tests**: All tests passed âœ…" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "${{ needs.setup.outputs.frontend_changed }}" == "true" ]]; then
            echo "- **Frontend Tests**: All tests passed âœ…" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- **Docker Builds**: All containers built successfully âœ…" >> $GITHUB_STEP_SUMMARY
          echo "- **Linting**: Completed (warnings allowed) âš ï¸" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Production (cost-fx.com)" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend URL**: https://cost-fx.com" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend URL**: https://cost-fx.com/api/v1" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.build.outputs.backend_built }}" == "true" ]]; then
            echo "- **Backend Image**: ${{ needs.build.outputs.backend_image }}" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "${{ needs.build.outputs.frontend_built }}" == "true" ]]; then
            echo "- **Frontend Image**: ${{ needs.build.outputs.frontend_image }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Fast ECS deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "_This deployment only updated application code. For infrastructure changes, use the manual deploy script._" >> $GITHUB_STEP_SUMMARY
